% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MM_Grid_FGMRM.R
\name{MM_Grid_FGMRM}
\alias{MM_Grid_FGMRM}
\title{Majorization-Minimization Algorithm over Lambda-Alpha Grid for Finite
Gaussian Mixture Regression Models}
\usage{
MM_Grid_FGMRM(
  g,
  x,
  y,
  tol = 0.001,
  max_iter = 500,
  lambda = NULL,
  lambda_max = NULL,
  n_lambda = 100,
  alpha = seq(0, 1, by = 0.1),
  verbose = TRUE,
  penalty = TRUE,
  random = FALSE,
  n_random_la = 100,
  parallel = TRUE
)
}
\arguments{
\item{g}{An integer greater than or equal to one representing the
number of mixture components (groups) in a finite Gaussian mixture regression
model.}

\item{x}{Design matrix. A numeric matrix of size n x p where the number of
rows is equal to the number of observations n, and the number of columns is
equal to the number of covariates p.}

\item{y}{Response vector. Either a numeric vector, or something coercible to
one.}

\item{tol}{A non-negative numeric value specifying the stopping criteria for
the MM algorithm (default value is 10e-04). If the difference in value of the
objective function being minimized is within tol in two consecutive
iterations, then the algorithm stops.}

\item{max_iter}{An integer greater than or equal to one specifying the
maximum number of iterations ran within the MM algorithm. Default value is
500.}

\item{lambda}{A list of length G of numeric vectors containing non-negative
tuning parameters specifying various strengths of the sparse group lasso
penalty. Finite Gaussian mixture models will be estimated using each lambda
value. Default value is NULL as the function will initialize lambdas for each
group count from 2 to G using an algorithm.}

\item{lambda_max}{A non-negative numeric value specifying the maximum lambda
value (tuning parameter) used in creation of each lambda vector. Default
value is NULL as the function will initialize lambda_max for each group count
from 2 to G using an algorithm.}

\item{n_lambda}{An integer greater than one (default value 100) specifying
the length of the lambda vector for each group count from 2 to G.}

\item{alpha}{A numeric vector containing values between zero and one
inclusive specifying different weights between the lasso penalty and group
lasso penalty being applied (GS). Alpha = 1 gives the lasso fit and alpha = 0
gives the group lasso fit (GS). Default value is a numeric vector of length
11: c(0, 0.1, 0.2, ..., 1).}

\item{verbose}{A logical value which, if true (default value), allows the
function to print progress updates.}

\item{penalty}{A logical value which, if true (default value), allows the
function to apply the sparse group lasso penalty to the regression parameter
updates and objective function within iterations of the MM algorithm.}

\item{random}{A logical value which, if true (false is the default value),
allows the function to take a random sample of size n_random_la from the
lambda-alpha pairs and run the MM algorithm over the reduced grid.}

\item{n_random_la}{A non-negative integer (default value 100) specifying the
number of lambda-alpha pairs to be sampled when random is TRUE.}

\item{parallel}{A logical value which, if true (default value), allows the
function to run parallel workers to increase computational speed.}
}
\value{
An object of class FGMRM containing the parameters of the estimated
finite Gaussian mixture regression model (bic, log_likelihood, beta, pi,
sigma, z, z_hard, y_hat, mse, mse_fitted, alpha, lambda), the optimal group
count, and the parameters of models with the same alpha and group count for
plotting purposes.
}
\description{
Applies the Majorization-Minimization Algorithm to the inputted data over all
lambda-alpha pairs given the specified parameters to estimate a finite
Gaussian mixture regression model. The function chooses the model with the
lowest bic. It can be ran sequentially or in parallel. This function is used
during model estimation.
}
\examples{

# Simulate data
set.seed(123)

n <- 500
G <- 3
p <- 10
rho = 0.2

# ----true parameters for 3 clusters----
sigma_squared_true <- c(3, 1.5, 1)
pi_true <- c(0.4, 0.4, 0.2)
beta_true <- matrix(c(
-1, -3.22, 0, 0, 0, 0, 0.583, 0, 5.17, 0, 0,
1, 0, 0, 0, 0, 0, -4.56, 0.514, -2.98, 0, 0,
3, 0, 0, 0, 3.11, 0, 0, 0, -3.11, 0, 0
), nrow = G, byrow = TRUE)

# ----generate correlation matrix----
cor_mat <- outer(1:p, 1:p, function(i, j) rho^abs(i - j))
Sigma <- cor_mat

# ----simulate each group----
x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)

# ----generate responsibilities----
z <- rmultinom(n, size = 1, prob = pi_true)
groups <- apply(z, 2, which.max)

# ----b0 + b1x1 + b2x2 + ... + bkxk----
mu_vec <- rowSums(cbind(1, x) * beta_true[groups, ])

# ----simulate response y----
y <- rnorm(n, mean = mu_vec, sd = sqrt(sigma_squared_true[groups]))

model_one <- MM_Grid_FGMRM(g = 3, x, y, verbose = FALSE)
model_two <- MM_Grid_FGMRM(g = 3, x, y, penalty = FALSE, verbose = FALSE)
model_three <- MM_Grid_FGMRM(g = 3, x, y, random = TRUE, verbose = FALSE)
model_four <- MM_Grid_FGMRM(g = 3, x, y, parallel = FALSE, verbose = FALSE)
}
